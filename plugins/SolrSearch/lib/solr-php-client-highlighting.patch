Index: Apache/Solr/Response.php
===================================================================
--- Apache/Solr/Response.php	(revision 53)
+++ Apache/Solr/Response.php	(working copy)
@@ -86,6 +86,14 @@
 	 */
 	protected $_createDocuments = true,
 			$_collapseSingleValueArrays = true;
+			
+	/**
+	 * The name of the id field.  This is used if highlighting is active, 
+	 * due to the fact that in the response they are categorized by id.
+	 * 
+	 * @var string
+	 */
+	protected $_id_field;
 
 	/**
 	 * Constructor. Takes the raw HTTP response body and the exploded HTTP headers
@@ -94,11 +102,12 @@
 	 * @param boolean $createDocuments Whether to convert the documents json_decoded as stdClass instances to Apache_Solr_Document instances
 	 * @param boolean $collapseSingleValueArrays Whether to make multivalued fields appear as single values
 	 */
-	public function __construct(Apache_Solr_HttpTransport_Response $response, $createDocuments = true, $collapseSingleValueArrays = true)
+	public function __construct(Apache_Solr_HttpTransport_Response $response, $createDocuments = true, $collapseSingleValueArrays = true, $id_field='id')
 	{
 		$this->_response = $response;
 		$this->_createDocuments = (bool) $createDocuments;
 		$this->_collapseSingleValueArrays = (bool) $collapseSingleValueArrays;
+		$this->_id_field = $id_field;
 	}
 
 	/**
@@ -150,6 +159,26 @@
 	{
 		return $this->_response->getBody();
 	}
+	
+	/**
+	 * Get the field that is set as the id field.
+	 * 
+	 * @return string the name of the id field
+	 */
+	public function getIdField()
+	{
+		return $this->_id_field;
+	}
+	
+	/**
+	 * Set the name of the id field.
+	 * 
+	 * @param string $id_field the name of the id field
+	 */
+	public function setIdField($id_field)
+	{
+		$this->_id_field = $id_field;
+	}
 
 	/**
 	 * Magic get to expose the parsed data and to lazily load it
@@ -234,8 +263,33 @@
 					}
 
 					$document->$key = $value;
+					
+					if ( $key == $this->_id_field )
+					{
+						$cur_id = $value;
+					}
 				}
 
+				// If highlighting is active, and there is something for the
+				// current document and we are creating documents
+				if ( isset($data->highlighting) && isset($data->highlighting->$cur_id) && $this->_createDocuments )
+				{
+					// Then for each field we need to either just add it, or collapse the
+					// arrays depending upon the settings.
+					foreach ( $data->highlighting->$cur_id as $field => $highlighting )
+					{
+						if ( $this->_collapseSingleValueArrays && count($highlighting) <= 1 )
+						{
+							$document->setFieldHighlighting($field, array_shift($highlighting));
+						} 
+						else
+						{
+							$document->setFieldHighlighting($field, $highlighting);
+						}
+					}
+					
+				}
+
 				$documents[] = $document;
 			}
 
Index: Apache/Solr/Service.php
===================================================================
--- Apache/Solr/Service.php	(revision 53)
+++ Apache/Solr/Service.php	(working copy)
@@ -47,6 +47,8 @@
 
 require_once(dirname(__FILE__) . '/HttpTransport/Interface.php');
 
+require_once(dirname(__FILE__) . '/HighlightOpts.php');
+
 /**
  * Starting point for the Solr API. Represents a Solr server resource and has
  * methods for pinging, adding, deleting, committing, optimizing and searching.
@@ -126,7 +128,7 @@
 	 *
 	 * @var string
 	 */
-	protected $_host, $_port, $_path;
+	protected $_host, $_port, $_path, $_id_field;
 
 	/**
 	 * Whether {@link Apache_Solr_Response} objects should create {@link Apache_Solr_Document}s in
@@ -180,8 +182,15 @@
 	 * @var Apache_Solr_HttpTransport_Interface
 	 */
 	protected $_httpTransport = false;
-
+	
 	/**
+	 * The options for highlighting.  Null if they are not set.
+	 *
+	 * @var Apache_Solr_HighlightOpts
+	 */
+	protected $_highlight_opts = null;
+	
+	/**
 	 * Escape a value for special query characters such as ':', '(', ')', '*', '?', etc.
 	 *
 	 * NOTE: inside a phrase fewer characters need escaped, use {@link Apache_Solr_Service::escapePhrase()} instead
@@ -232,11 +241,12 @@
 	 * @param string $path
 	 * @param Apache_Solr_HttpTransport_Interface $httpTransport
 	 */
-	public function __construct($host = 'localhost', $port = 8180, $path = '/solr/', $httpTransport = false)
+	public function __construct($host = 'localhost', $port = 8180, $path = '/solr/', $httpTransport = false, $id_field = 'id')
 	{
 		$this->setHost($host);
 		$this->setPort($port);
 		$this->setPath($path);
+		$this->setIdField($id_field);
 
 		$this->_initUrls();
 
@@ -331,7 +341,7 @@
 		$httpTransport = $this->getHttpTransport();
 
 		$httpResponse = $httpTransport->performGetRequest($url, $timeout);
-		$solrResponse = new Apache_Solr_Response($httpResponse, $this->_createDocuments, $this->_collapseSingleValueArrays);
+		$solrResponse = new Apache_Solr_Response($httpResponse, $this->_createDocuments, $this->_collapseSingleValueArrays, $this->_id_field);
 
 		if ($solrResponse->getHttpStatus() != 200)
 		{
@@ -357,7 +367,7 @@
 		$httpTransport = $this->getHttpTransport();
 
 		$httpResponse = $httpTransport->performPostRequest($url, $rawPost, $contentType, $timeout);
-		$solrResponse = new Apache_Solr_Response($httpResponse, $this->_createDocuments, $this->_collapseSingleValueArrays);
+		$solrResponse = new Apache_Solr_Response($httpResponse, $this->_createDocuments, $this->_collapseSingleValueArrays, $this->_id_field);
 
 		if ($solrResponse->getHttpStatus() != 200)
 		{
@@ -493,8 +503,31 @@
 	{
 		$this->_httpTransport = $httpTransport;
 	}
+	
+	/**
+	 * Get the currently configured id field.  This is the field that
+	 * will be used to pair documents with their highlighting information.
+	 * 
+	 * @return string
+	 */
+	public function getIdField()
+	{
+		return $this->_id_field;
+	}
 
 	/**
+	 * Set the id field used.  This is used by the highlighting to
+	 * determine which field to use to pair the highlighting information
+	 * received with the Apache_Solr_Documents.
+	 *
+	 * @param string $id_field the name of the field that is the id
+	 */
+	public function setIdField($id_field)
+	{
+		$this->_id_field=$id_field;
+	}
+
+	/**
 	 * Set the create documents flag. This determines whether {@link Apache_Solr_Response} objects will
 	 * parse the response and create {@link Apache_Solr_Document} instances in place.
 	 *
@@ -617,6 +650,36 @@
 	}
 
 	/**
+	 * Set the {@link Apache_Solr_HighlightOpts} that control the
+	 * highlighting options.  If nothing is fed in, then it will just
+	 * activate highlighting. (The same as adding hl=true to the $params
+	 * in the search method).
+	 *
+	 * Set it to null if you do not want any options (i.e. no highlighting).
+	 *
+	 * @param Apache_Solr_HighlightOpts $options this is the set of highlight options
+	 */
+	public function setHighlightOptions($options='')
+	{
+		if ( $options === '' )
+		{
+			$options = new Apache_Solr_HighlightOpts();
+		}
+		$this->_highlight_opts = $options;
+	}
+
+	/**
+	 * Get the currently set {@link Apache_Solr_HighlightOpts}.  This will
+	 * allow you to make changes to the already set options.
+	 *
+	 * @return Apache_Solr_HighlightOpts the options that are currently set to this object
+	 */
+	public function getHighlightOptions()
+	{
+		return $this->_highlight_opts;
+	}
+
+	/**
 	 * Call the /admin/ping servlet, can be used to quickly tell if a connection to the
 	 * server is able to be made.
 	 *
@@ -1087,8 +1150,17 @@
 			$params = array();
 		}
 		
+		
 		// construct our full parameters
 
+		// Check to see if we have any options set for highlighting
+		if ( $this->_highlight_opts != null ) 
+		{
+			// If we do, then merge the parameters.  If there are any parameters that are set
+			// specifically by the params array, they will overwrite those set by the highlight options
+			$params = array_merge($this->_highlight_opts->getParamArray(), $params); 
+		}
+		
 		// common parameters in this interface
 		$params['wt'] = self::SOLR_WRITER;
 		$params['json.nl'] = $this->_namedListTreatment;
Index: Apache/Solr/SolrOpts.php
===================================================================
--- Apache/Solr/SolrOpts.php	(revision 0)
+++ Apache/Solr/SolrOpts.php	(revision 0)
@@ -0,0 +1,277 @@
+<?php
+/**
+ * Copyright (c) 2010, Thomas Joiner
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  - Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of Conduit Internet Technologies, Inc. nor the names of
+ *    its contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * @copyright Copyright (c) 2010, Thomas Joiner
+ * @license New BSD (http://solr-php-client.googlecode.com/svn/trunk/COPYING)
+ *
+ * @package Apache
+ * @subpackage Solr
+ * @author Thomas Joiner
+ */
+
+/**
+ * This class is an abstract class for 
+ */
+abstract class Apache_Solr_SolrOpts
+{
+	/**
+	 * SVN Revision meta data for this class
+	 */
+	const SVN_REVISION = '$Revision$';
+
+	/**
+	 * SVN ID meta data for this class
+	 */
+	const SVN_ID = '$Id$';
+
+	/**
+	 * Parameter types for this class
+	 */
+	const BOOLEAN_PARAM = 'bool';
+	const CSV_PARAM = 'csv';
+	const NUMERIC_PARAM = 'num';
+	const STRING_PARAM = 'str';
+
+	/**
+	 * The key in the array in which the overrides will be stored.
+	 */
+	const OVERRIDE_KEY = 'overrides';
+	
+	/**
+	 * A special constant for the value that will be used to indicate
+	 * an unset value.
+	 *
+	 * This would be where it was declared, but due to the fact that PHP doesn't allow you to
+	 * instantiate classes in a definition, NO GO!!!
+	 *
+	 * const UNSET_VALUE = new stdClass();
+	 */
+	
+	/**
+	 * The variable that holds all the information about the query parameters.
+	 *
+	 * @var array
+	 */
+	private $_param_map = array();
+	
+	/**
+	 * This method will set a parameter's value.  If the value
+	 * given is the same as the default, it will just remove value
+	 * for the parameter.
+	 *
+	 * @param string $param the parameter to be set
+	 * @param mixed $value the value to set it to
+	 */
+	protected function setParameterValue($param, $value) 
+	{
+		$default = $this->getDefaultValue($param);
+		
+		// Check to see if the value given is the default value for that parameter
+		if ( $value == $default ) 
+		{
+			// If it is, check to see if there are any overridden fields
+			if ( count($this->_param_map[$param][self::OVERRIDE_KEY]) == 0 ) 
+			{
+				// If there aren't, then just unset the whole parameter
+				unset($this->_param_map[$param]);
+			} 
+			elseif ( isset($this->_param_map[$param]) ) 
+			{
+				// Otherwise, remove the value so that key doesn't exist anymore
+				unset($this->_param_map[$param]['value']);
+			}
+		} 
+		else
+		{
+			// If the value given wasn't the same as the default value, then check to see if
+			// the parameter information has already been added
+			if ( !isset($this->_param_map[$param]) ) 
+			{
+				// If it hasn't been, create it
+				$this->_param_map[$param] = array( 'value' => $value, 'type' => $this->getParamType($param) );
+				// Make sure the current param is overrideable before we create the array to hold the overrides
+				if ( $this->isOverrideable($param) )
+				{
+					$this->_param_map[$param][self::OVERRIDE_KEY] = array();
+				}
+			}
+			else 
+			{
+				// If it already existed, just change the value.
+				$this->_param_map[$param]['value'] = $value;
+			}
+		}
+	}
+	
+	/**
+	 * This function retrieves the value of a parameter.  If the value has not been
+	 * set then it will return the default value.
+	 *
+	 * @return mixed the value of the parameter
+	 */
+	protected function getParameterValue($param) 
+	{
+		return ( !isset($this->_param_map[$param]) || !isset($this->_param_map[$param]['value']) ? $this->getDefaultValue($param) : $this->_param_map[$param]['value'] );
+	}
+	
+	/**
+	 * This method will add an override to a particular field for the given parameter. This
+	 * method will silently not add the override if the parameter cannot be overridden.
+	 *
+	 * @param string $param the parameter to be set
+	 * @param string $field the field to be set
+	 * @param mixed $value the value to set it to
+	 */
+	protected function addFieldOverride($param, $field, $value) 
+	{
+		$default = $this->getDefaultValue($param);
+		
+		// Check that the given parameter is overrideable
+		if ( $this->isOverrideable($param) ) 
+		{
+			// We don't want to bother to send the parameter if it just going to be the default,
+			// unless the main value has been overridden and we want to put the value for this
+			// particular field back to default
+			if ( $value != $default || $this->_param_map[$param]['value'] != $default ) 
+			{
+				// If we are adding the override without setting the main value, then we need to
+				// create the structure as well as setting the value
+				if ( !isset($this->_param_map[$param]) ) 
+				{
+					$this->_param_map[$param] = array( 'type' => $this->getParamType($param), self::OVERRIDE_KEY => array( $field => $value ) );
+				}
+				else
+				{
+					// Set the value
+					$this->_param_map[$param][self::OVERRIDE_KEY][$field] = $value;
+				}
+			}
+		}
+	}
+	
+	/**
+	 * This method retrieves the field override for the given parameter/field pair.
+	 * 
+	 * @param string $param the parameter to be set
+	 * @param string $field the field to be set
+	 * @return mixed the override for the given field
+	 */
+	protected function getFieldOverride($param, $field)
+	{
+		return $this->_param_map[$param][self::OVERRIDE_KEY][$field];
+	}
+
+	
+	/**
+	 * This function removes an override from a field
+	 * 
+	 * @param string $param the parameter from which the override needs to be removed
+	 * @param string $field the field from which to remove the override
+	 */
+	protected function removeFieldOverride($param, $field) 
+	{
+		unset($this->_param_map[$param][self::OVERRIDE_KEY][$field]);
+	}
+	
+	/**
+	 * This function produces an array of the parameters that this object encapsulates.
+	 * The format is such that it can be consummed by http_build_query.
+	 *
+	 * @return array the parameters that this object needs added to the request.
+	 */
+	public function getParamArray() {
+		$data = array();
+		
+		// For every parameter in the map
+		foreach ( $this->_param_map as $param => $info ) 
+		{
+			// We make sure that the value is set ( in case all they did was add an override
+			// or they set it to the default value )
+			if( isset($info['value']) ) {
+				switch ( $info['type'] ) 
+				{
+				case self::CSV_PARAM:
+					// If it is a CSV param, implode it using commas as glue
+					$data[$param] = implode(',', $info['value']);
+					break;
+				case self::BOOLEAN_PARAM:
+					// If it is boolean, convert to the english words
+					$data[$param] = ( $info['value'] === true ? "true" : "false" );
+					break;
+				default:
+					// Otherwise just add it.
+					$data[$param] = $info['value'];
+					break;
+				}
+			}
+			
+			// If this is an overrideable parameter
+			if ( isset($info[self::OVERRIDE_KEY]) )
+			{
+				// For each of the overrides
+				foreach ( $info[self::OVERRIDE_KEY] as $field => $value )
+				{
+					// Add it to the parameters as f.<field name>.<parameter name> as
+					// described on http://wiki.apache.org/solr/SimpleFacetParameters#Parameters
+					// and http://wiki.apache.org/solr/HighlightingParameters#HowToOverride
+					$data["f.$field.$param"] = $value;
+				}
+			}
+		}
+		
+		// Return the array.
+		return $data;
+	}
+	
+	/**
+	 * This function should return whether or not the $param fed in accepts field overrides
+	 * or not.
+	 *
+	 * @param string $param this is the parameter you are testing for overrideability
+	 * @return boolean true if it overrideable, false if it isn't
+	 */
+	abstract protected function isOverrideable($param);
+	
+	/**
+	 * This function returns the type of parameter that $param is.
+	 *
+	 * @param string $param the parameter whose type you want
+	 * @return string the type the parameter is.
+	 */
+	abstract protected function getParamType($param);
+	
+	/**
+	 * This function returns the default value of a parameter.
+	 *
+	 * @param string $param the parameter you want the default value for
+	 * @return string the default value of the parameter
+	 */
+	abstract protected function getDefaultValue($param);
+
+}
\ No newline at end of file
Index: Apache/Solr/HighlightOpts.php
===================================================================
--- Apache/Solr/HighlightOpts.php	(revision 0)
+++ Apache/Solr/HighlightOpts.php	(revision 0)
@@ -0,0 +1,931 @@
+<?php
+/**
+ * Copyright (c) 2010, Thomas Joiner
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  - Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of Conduit Internet Technologies, Inc. nor the names of
+ *    its contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * @copyright Copyright (c) 2010, Thomas Joiner
+ * @license New BSD (http://solr-php-client.googlecode.com/svn/trunk/COPYING)
+ *
+ * @package Apache
+ * @subpackage Solr
+ * @author Thomas Joiner
+ */
+
+require_once(dirname(__FILE__) . '/SolrOpts.php');
+ 
+/**
+ * This class is a class that provides a class interface for Solr's highlighting
+ * options.
+ */
+class Apache_Solr_HighlightOpts extends Apache_Solr_SolrOpts
+{
+	/**
+	 * SVN Revision meta data for this class
+	 */
+	const SVN_REVISION = '$Revision$';
+
+	/**
+	 * SVN ID meta data for this class
+	 */
+	const SVN_ID = '$Id$';
+	
+	private static $param_info = array ( 
+		'hl' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::BOOLEAN_PARAM, 'default' => false ),
+		'hl.fl' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::CSV_PARAM, 'default' => array() ),
+		'hl.snippets' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::NUMERIC_PARAM, 'default' => 1 ),
+		'hl.fragsize' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::NUMERIC_PARAM, 'default' => 100 ),
+		'hl.mergeContiguous' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::BOOLEAN_PARAM, 'default' => false ),
+		'hl.requireFieldMatch' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::BOOLEAN_PARAM, 'default' => false ),
+		'hl.maxAnalyzedChars' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::NUMERIC_PARAM, 'default' => 512000 ),
+		'hl.alternateField' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => '' ),
+		'hl.maxAlternateFieldLength' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::NUMERIC_PARAM, 'default' => 0),
+		'hl.formatter' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => 'simple' ),
+		'hl.simple.pre' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => '<em>' ),
+		'hl.simple.post' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => '</em>' ),
+		'hl.fragmenter' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => 'gap' ),
+		'hl.fragListBuilder' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => ''),
+		'hl.fragmentsBuilder' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => ''),
+		'hl.useFastVectorHighlighter' => array( 'ovr' => true, 'type' => Apache_Solr_SolrOpts::BOOLEAN_PARAM, 'default' => false),
+		'hl.usePhraseHighlighter' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::BOOLEAN_PARAM, 'default' => false),
+		'hl.highlightMultiTerm' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::BOOLEAN_PARAM, 'default' => false),
+		'hl.regex.slop' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::NUMERIC_PARAM, 'default' => 0.6),
+		'hl.regex.pattern' => array( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::STRING_PARAM, 'default' => ''),
+		'hl.regex.maxAnalyzedChars' => array ( 'ovr' => false, 'type' => Apache_Solr_SolrOpts::NUMERIC_PARAM, 'default' => 10000)
+	);
+	
+	/**
+	 * The only constructor for this is no-argument. All it does is set highlighting to be on.
+	 */
+	public function __construct() {
+		// Set highlighting to on.
+		$this->setParameterValue('hl', true);
+	}
+	
+	/**
+	 * This function allows you to set which fields will be highlighted.
+	 * 
+	 * @param array $fields an array that contains the names of the fields you want highlighted
+	 */
+	public function setHighlightedFields($fields=array()) 
+	{
+		// If it is a scalar value, wrap it in an array.
+		if ( !is_array($fields) ) {
+			$fields = array($fields);
+		}
+		
+		// And set the value
+		$this->setParameterValue('hl.fl', $fields);
+	}
+	
+	/**
+	 * This function adds a field to the list of fields to be highlighted.
+	 * 
+	 * @param mixed $field_to_add the field(s) that you want added. This can be an array or a single field
+	 */
+	public function addHighlightedField($field_to_add) 
+	{
+		// Get the current list of fields.
+		$fields = $this->getParameterValue('hl.fl');
+		
+		// Check to see if it already was set
+		if ( is_array($fields) )
+		{
+			// If the field(s) to add is an array, merge it with the
+			// previous array
+			if ( is_array($field_to_add) ) 
+			{
+				$fields = array_merge($fields, $field_to_add);
+			} 
+			else
+			{
+				// Otherwise just add it.
+				$fields[] = $field_to_add;
+			}
+		} else {
+			// If it wasn't, this is the first field.
+			if ( is_array($field_to_add) ) 
+			{
+				$fields = $field_to_add;
+			}
+			else
+			{
+				$fields = array( $field );
+			}
+		}
+		
+		// Set it back
+		$this->setParameterValue('hl.fl', $fields);
+	}
+	
+	/**
+	 * This function removes a field from the list of fields to be highlighted.
+	 * 
+	 * @param mixed $field_to_add the field(s) that you want added. This can be an array or a single field
+	 */
+	public function removeHighlightedField($field_to_remove) 
+	{
+		// Get the current list of fields
+		$fields = $this->getParameterValue('hl.fl');
+		
+		// Check to see if it was already set
+		if ( is_array($fields) )
+		{
+			// If the fields you want to remove are an array
+			// calculate the difference
+			if ( is_array($field_to_remove) )
+			{
+				$fields = array_diff($fields, $field_to_remove);
+			}
+			else
+			{
+				// Otherwise, just unset that particular index
+				unset($fields[array_search($field_to_remove, $fields)]);
+			}
+		}
+		else 
+		{
+			$fields = self::$param_info['hl.fl']['default'];
+		}
+		
+		// Set it back
+		$this->setParameterValue('hl.fl', $fields);
+	}
+	
+	/**
+	 * Get an array of the highlighted fields.
+	 * @return array the list of highlighted fields
+	 */
+	public function getHighlightedFields() 
+	{
+		return $this->getParameterValue('hl.fl');
+	}
+	
+	/**
+	 * Set the number of snippets to generate for each field.
+	 * 
+	 * @param int $num the number of snippets to generate per field
+	 */
+	public function setNumSnippets($num) 
+	{
+		$this->setParameterValue('hl.snippets', $num);
+	}
+	
+	/**
+	 * Get the number of snippets each field is set to generate.
+	 * 
+	 * @return the number of snippets
+	 */
+	public function getNumSnippets() 
+	{
+		return $this->getParameterValue('hl.snippets');
+	}
+	
+	/**
+	 * This function sets the override for a single field.
+	 * @param $field the field to override
+	 * @param $num the number of snippets for that field to generate
+	 */
+	public function setNumSnippetsFieldOverride($field, $num) 
+	{
+		$this->addFieldOverride('hl.snippets', $field, $num);
+	}
+	
+	/**
+	 * This function returns the current value for the override for the
+	 * given field (if it exists).
+	 * 
+	 * @param string $field the field you want to know the override of
+	 */
+	public function getNumSnippetsFieldOverride($field) 
+	{
+		return $this->getFieldOverride('hl.snippets', $field);
+	}
+	
+	/**
+	 * Remove a previously set override.
+	 * 
+	 * @param string $field the field for which to remove the override
+	 */
+	public function removeNumSnippetsFieldOverride($field) 
+	{
+		$this->removeFieldOverride('hl.snippets', $field);
+	}
+	
+	/**
+	 * Set the size of the fragments that you want the highlighting to be
+	 * split into.  Default is 100. 0 means don't fragment.
+	 * @param int $size
+	 */
+	public function setFragmentSize($size)
+	{
+		$this->setParameterValue('hl.fragsize', $size);
+	}
+	
+	/**
+	 * Get the currently set fragment size.
+	 * 
+	 * @return int the currently set fragment size
+	 */
+	public function getFragmentSize()
+	{
+		return $this->getParameterValue('hl.fragsize');
+	}
+	
+	/**
+	 * Set the field override for the fragment size.
+	 * @param string $field the field to set the override for
+	 * @param int $size the size to set the field to
+	 */
+	public function setFragmentSizeOverride($field, $size)
+	{
+		$this->addFieldOverride('hl.fragsize', $field, $size);
+	}
+	
+	/**
+	 * Get the field override for a given field's fragment size. 
+	 * @param $field the field to get the override for
+	 */
+	public function getFragmentSizeOverride($field) 
+	{
+		return $this->getFieldOverride('hl.fragsize', $field);
+	}
+	
+	/**
+	 * Remove the fragment size override on a field.
+	 * 
+	 * @param string $field the field to remove it for
+	 */
+	public function removeFragmentSizeOverride($field)
+	{
+		$this->removeFieldOverride('hl.fragsize', $field);
+	}
+	
+	/**
+	 * This setting determines whether or not contiguous fragments should be
+	 * collapsed into a single fragment.
+	 * 
+	 * @param boolean $mergeContiguous whether or not do to it
+	 */
+	public function setMergeContiguous($mergeContiguous) 
+	{
+		$this->setParameterValue('hl.mergeContiguous', $mergeContiguous);
+	}
+	
+	/**
+	 * Get the current setting for merge contiguous.
+	 * @return boolean true if it is set to merge contiguous fragments, false if not
+	 */
+	public function getMergeContiguous() 
+	{
+		return $this->getParameterValue('hl.mergeContiguous');
+	}
+	
+	/**
+	 * Set a field override for merge contiguous.
+	 * 
+	 * @param string $field the field to set it for
+	 * @param boolean $value the value to set it to
+	 */
+	public function addMergeContiguousFieldOverride($field, $value) 
+	{
+		$this->addFieldOverride('hl.mergeContiguous', $field, $value);
+	}
+	
+	/**
+	 * Get the field override for merge contiguous.
+	 * 
+	 * @param string $field the field whose value you want
+	 * @return boolean the value of the setting for that field
+	 */
+	public function getMergeContiguousFieldOverride($field) 
+	{
+		return $this->getFieldOverride('hl.mergeContiguous', $field);
+	}
+	
+	/**
+	 * Remove a field override for merge contiguous.
+	 * @param string $field the field for which to remove it
+	 */
+	public function removeMergeContiguousFieldOverride($field) 
+	{
+		$this->removeFieldOverride('hl.mergeContiguous', $field);
+	}
+	
+	/**
+	 * If true, then a field will only be highlighted if the query matched in 
+	 * this particular field (normally, terms are highlighted in all requested
+	 * fields regardless of which field matched the query). This only takes 
+	 * effect if "hl.usePhraseHighlighter" is "true".
+	 * 
+	 * The default value is "false".
+	 * 	 
+	 * @param boolean $requireFieldMatch whether or not to require field match
+	 */
+	public function setRequireFieldMatch($requireFieldMatch) 
+	{
+		$this->setParameterValue('hl.requireFieldMatch', $requireFieldMatch);		
+	}
+	
+	/**
+	 * Get whether or not a field match is required.
+	 * 
+	 * @return boolean true if field match is required, false if not
+	 */
+	public function getRequireFieldMatch() 
+	{
+		return $this->getParameterValue('hl.requireFieldMatch');
+	}
+	
+	/**
+	 * How many characters into a document to look for suitable snippets.
+	 * 
+	 * The default value is "51200".
+	 * 
+	 * @param int $max the new max
+	 */
+	public function setMaxAnalyzedChars($max) 
+	{
+		$this->setParameterValue('hl.maxAnalyzedChars',$max);
+	}
+	
+	/**
+	 * Get the max number of characters to analyze.
+	 * @return int the max number of characters to analyze
+	 */
+	public function getMaxAnalyzedChars()
+	{
+		return $this->getParameterValue('hl.maxAnalyzedChars');
+	}
+	
+	/**
+	 * If a snippet cannot be generated, this field will be used instead.
+	 * 
+	 * The default value is to not have one.
+	 * 
+	 * @param string $field the field to use as the alternate field
+	 */
+	public function setAlternateField($field) 
+	{
+		$this->setParameterValue('hl.alternateField', $field);
+	}
+	
+	/**
+	 * Retrieve the field that will be used if a snippet cannot be generated.
+	 * 
+	 * @return string the field that will be used
+	 */
+	public function getAlternateField()
+	{
+		return $this->getParameterValue('hl.alternateField', $field);
+	}
+	
+	/**
+	 * Add an override to the alternate field.
+	 * 
+	 * @param string $field_to_override the field whose value you want to override
+	 * @param string $alternate_field the value to set that override to
+	 */
+	public function addAlternateFieldOverride($field_to_override, $alternate_field)
+	{
+		$this->addFieldOverride('hl.alternateField', $field_to_override, $alternate_field);
+	}
+	
+	/**
+	 * Get the value that the overridden field was overridden to.
+	 * 
+	 * @param string $overridden_field the field that was overridden
+	 * @return string the field that the $overridden_field was set to use as its default summary
+	 */
+	public function getAlternateFieldOverride($overridden_field)
+	{
+		return $this->getFieldOverride('hl.alternateField',$overridden_field);
+	}
+	
+	/**
+	 * Remove a field override from the alternate field.
+	 * 
+	 * @param string $overridden_field the field from which you want to remove the override
+	 */
+	public function removeAlternateFieldOverride($overridden_field)
+	{
+		$this->removeFieldOverride('hl.alternateField', $overridden_field);
+	}
+	
+	/**
+	 * If hl.alternateField is specified, this parameter specifies the maximum 
+	 * number of characters of the field to return  Solr1.3. Any value less 
+	 * than or equal to 0 means unlimited.
+	 * 
+	 * The default value is unlimited.
+	 * 
+	 * @param int $length the length to restrain the alternate field to
+	 */
+	public function setMaxAlternateFieldLength($length)
+	{
+		$this->setParameterValue('hl.maxAlternateFieldLength',$length);
+	}
+	
+	/**
+	 * Get the value set for the max length of the alternate field.
+	 * 
+	 * @return int the max length of the alternate field
+	 */
+	public function getMaxAlternateFieldLength()
+	{
+		return $this->getParameterValue('hl.maxAlternateFieldLength');
+	}
+	
+	/**
+	 * Specify a formatter for the highlight output. Currently the only 
+	 * legal value is "simple", which surrounds a highlighted term with 
+	 * a customizable pre- and post text snippet. 
+	 * 
+	 * The default value is "simple".
+	 * 
+	 * @param unknown_type $formatter
+	 */
+	public function setFormatter($formatter) 
+	{
+		$this->setParameterValue('hl.formatter', $formatter);
+	}
+	
+	/**
+	 * Get the formatter that is currently set.
+	 * 
+	 * @return string the current formatter
+	 */
+	public function getFormatter() 
+	{
+		return $this->getParameterValue('hl.formatter');
+	}
+	
+	/**
+	 * Override what formatter a certain field uses.
+	 * @param string $field the field to override
+	 * @param string $formatter the formatter for that field to use
+	 */
+	public function addFormatterFieldOverride($field, $formatter)
+	{
+		$this->addFieldOverride('hl.formatter', $field, $formatter);
+	}
+	
+	/**
+	 * Get the overridden formatter value for a field.
+	 * 
+	 * @param string $field the field to get the override for
+	 */
+	public function getFormatterFieldOverride($field)
+	{
+		return $this->getFieldOverride('hl.formatter',$field);
+	}
+	
+	/**
+	 * Remove an override for a fields formatter.
+	 * 
+	 * @param string $field the field to remove the override from
+	 */
+	public function removeFormatterFieldOverride($field)
+	{
+		$this->removeFieldOverride('hl.formatter', $field);
+	}
+	
+	/**
+	 * Set the text which appears before a highlighted term when 
+	 * using the simple formatter. 
+	 * 
+	 * @param string $value the string to prepend
+	 */
+	public function setPreFormat($value)
+	{
+		$this->setParameterValue('hl.simple.pre',$value);
+	}
+	
+	/**
+	 * Get what is prepended to highlighted terms.
+	 * 
+	 * @return string the value that is prepended to highlighted terms
+	 */
+	public function getPreFormat()
+	{
+		return $this->getParameterValue('hl.simple.pre');
+	}
+	
+	/**
+	 * Set a field override for the pre-formatting.
+	 * 
+	 * @param string $field the field to override
+	 * @param string $value the value to override it with
+	 */
+	public function addPreFormatFieldOverride($field, $value)
+	{
+		$this->addFieldOverride('hl.simple.pre', $field, $value);
+	}
+	
+	/**
+	 * Get the field override for pre-formatting for a given field.
+	 * @param string $field the field to get the override for
+	 */
+	public function getPreFormatFieldOverride($field)
+	{
+		return $this->getFieldOverride('hl.simple.pre', $field);
+	}
+	
+	/**
+	 * Remove the field override for pre-formatting for a given field.
+	 * 
+	 * @param string $field the field to remove it from
+	 */
+	public function removePreFormatFieldOverride($field)
+	{
+		$this->removeFieldOverride('hl.simple.pre', $field);
+	}
+	
+	/**
+	 * Set the text which appears after a highlighted term when 
+	 * using the simple formatter. 
+	 * 
+	 * @param string $value the string to append
+	 */
+	public function setPostFormat($value)
+	{
+		$this->setParameterValue('hl.simple.post',$value);
+	}
+	
+	/**
+	 * Get the text which appears after a highlighted term when 
+	 * using the simple formatter. 
+	 * 
+	 * @param string $value the string to append
+	 */
+	public function getPostFormat()
+	{
+		return $this->getParameterValue('hl.simple.post');
+	}
+	
+	/**
+	 * Add an override for the value that gets appended to a highlighted
+	 * term.
+	 * 
+	 * @param string $field the field to override
+	 * @param string $value the value to override it with
+	 */
+	public function addPostFormatFieldOverride($field, $value)
+	{
+		$this->addFieldOverride('hl.simple.post', $field, $value);
+	}
+	
+	/**
+	 * Get the override for the appended value for a highlighted term.
+	 * 
+	 * @param string $field the field to look at
+	 */
+	public function getPostFormatFieldOverride($field)
+	{
+		return $this->getFieldOverride('hl.simple.post', $field);
+	}
+	
+	/**
+	 * Remove the post-highlighting override for a field.
+	 * 
+	 * @param string $field the field to remove it for.
+	 */
+	public function removePostFormatFieldOverride($field)
+	{
+		$this->removeFieldOverride('hl.simple.post', $field);
+	}
+	
+	/**
+	 * Specify a text snippet generator for highlighted text. The standard 
+	 * fragmenter is gap (which is so called because it creates fixed-sized 
+	 * fragments with gaps for multi-valued fields). Another option is regex,
+	 * which tries to create fragments that "look like" a certain regular 
+	 * expression.
+	 *  
+	 * The default value is "gap"
+	 * 
+	 * @param string $value the text snippet generator to use
+	 */
+	public function setFragmenter($value)
+	{
+		$this->setParameterValue('hl.fragmenter',$value);
+	}
+	
+	/**
+	 * Get the text snippet generator that is being used.
+	 * 
+	 * @return string the text snippet generator that is being used
+	 */
+	public function getFragmenter()
+	{
+		return $this->getParameterValue('hl.fragmenter');
+	}
+	
+	/**
+	 * Override which text snippet generator a field uses.
+	 * 
+	 * @param string $field the field to override
+	 * @param string $value the text snippet generator to use
+	 */
+	public function addFragmenterFieldOverride($field, $value)
+	{
+		$this->addFieldOverride('hl.fragmenter', $field, $value);
+	}
+	
+	/**
+	 * Get the overridden value (if it exists) of which text snippet
+	 * generator a field uses.
+	 * 
+	 * @param string $field the field to check
+	 * @return string the text snippet generator it uses
+	 */
+	public function getFragmenterFieldOverride($field)
+	{
+		return $this->getFieldOverride('hl.fragmenter', $field);
+	}
+	
+	/**
+	 * Remove an overridden text snippet generator value for a
+	 * field.
+	 *  
+	 * @param string $field the field to remove it for
+	 */
+	public function removeFragmenterFieldOverride($field)
+	{
+		$this->removeFieldOverride('hl.fragmenter', $field);
+	}
+	
+	/**
+	 * Specify the name of SolrFragListBuilder. This parameter makes sense for 
+	 * FastVectorHighlighter only.
+	 *  
+	 * @param string $value the SolrFragListBuilder you wish to use.
+	 */
+	public function setFragListBuilder($value)
+	{
+		$this->setParameterValue('hl.fragListBuilder',$value);
+	}
+	
+	/**
+	 * Get the name of the SolrFragListBuilder you wish to use.
+	 * 
+	 * @return string the name of the SolrFragListBuilder being used
+	 */
+	public function getFragListBuilder()
+	{
+		return $this->getParameterValue('hl.fragListBuilder');
+	}
+	
+	/**
+	 * Specify the name of SolrFragmentsBuilder. This parameter makes sense for
+	 * FastVectorHighlighter only. 
+	 * 
+	 * @param string $value the name of the SolrFragmentsBuilder
+	 */
+	public function setFragmentsBuilder($value)
+	{
+		$this->setParameterValue('hl.fragmentsBuilder',$value);
+	}
+	
+	/**
+	 * Get the name of the SolrFragmentsBuilder that is being used.
+	 * 
+	 * @return string the name of the SolrFragmentsBuilder being used
+	 */
+	public function getFragmentsBuilder()
+	{
+		return $this->getParameterValue('hl.fragmentsBuilder');
+	}
+	
+	/**
+	 * Use FastVectorHighlighter. FastVectorHighlighter requires the field is 
+	 * termVectors=on, termPositions=on and termOffsets=on. This parameter 
+	 * accepts per-field overrides. 
+	 * 
+	 * The default value is "false" 
+	 * 
+	 * @param boolean $value true if you wish to use it, false if not
+	 */
+	public function setUseFastVectorHighlighter($value)
+	{
+		$this->setParameterValue('hl.useFastVectorHighlighter',$value);
+	}
+	
+	/**
+	 * Get whether or not the FastVectorHighlighter is being used.
+	 * 
+	 * @return boolean true if it is being used, false if it is not
+	 */
+	public function getUseFastVectorHighlighter()
+	{
+		return $this->getParameterValue('hl.useFastVectorHighlighter');
+	}
+	
+	/**
+	 * Override whether or not a field is using the FastVectorHighlighter.
+	 * 
+	 * @param string $field the field that you want to override the value for
+	 * @param boolean $value the value you want to override it with
+	 */
+	public function addUseFastVectorHighlighterFieldOverride($field, $value)
+	{
+		$this->addFieldOverride('hl.useFastVectorHighlighter', $field, $value);
+	}
+	
+	/**
+	 * Get the override for whether or not a field is using the FastVectorHighlighter.
+	 * 
+	 * @param string $field the field to check
+	 * @return boolean whether or not the FastVectorHighlighter is being used for that
+	 */
+	public function getUseFastVectorHighlighterFieldOverride($field)
+	{
+		return $this->getFieldOverride('hl.useFastVectorHighlighter', $field);
+	}
+	
+	/**
+	 * Remove the override for whether or not a field is using the FastVectorHighlighter.
+	 * 
+	 * @param string $field the field to remove it for
+	 */
+	public function removeUseFastVectorHighlighterFieldOverride($field)
+	{
+		$this->removeFieldOverride('hl.useFastVectorHighlighter', $field);
+	}
+	
+	/**
+	 * Use SpanScorer to highlight phrase terms only when they appear within the query 
+	 * phrase in the document. 
+	 * 
+	 * Default is false.
+	 * 
+	 * @param boolean $value true to do it, false to not
+	 */
+	public function setUsePhraseHighlighter($value)
+	{
+		$this->setParameterValue('hl.usePhraseHighlighter',$value);
+	}
+	
+	/**
+	 * Get whether or not to only highlight phrases.
+	 * 
+	 * @return boolean true if it only highlights phrases, false if not
+	 */
+	public function getUsePhraseHighlighter()
+	{
+		return $this->getParameterValue('hl.usePhraseHighlighter');
+	}
+	
+	/**
+	 * If the SpanScorer is also being used, enables highlighting for 
+	 * range/wildcard/fuzzy/prefix queries. 
+	 * 
+	 * Default is false.
+	 * 
+	 * @param boolean $value true to use them, false to not
+	 */
+	public function setHighlightMultiTerm($value)
+	{
+		$this->setParameterValue('hl.highlightMultiTerm',$value);
+	}
+	
+	/**
+	 * Get whether or not highlighting for range/wildcard/fuzzy/prefix
+	 * queries is being used.
+	 * 
+	 * @return boolean true if it is being used, false if not
+	 */
+	public function getHighlightMultiTerm()
+	{
+		return $this->getParameterValue('hl.highlightMultiTerm');
+	}
+	
+	/**
+	 * Factor by which the regex fragmenter can stray from the ideal fragment 
+	 * size (given by hl.fragsize) to accomodate the regular expression. For
+	 * instance, a slop of 0.2 with fragsize of 100 should yield fragments 
+	 * between 80 and 120 characters in length. It is usually good to provide
+	 * a slightly smaller fragsize when using the regex fragmenter.
+	 * 
+	 * The default value is ".6"
+	 * 
+	 * @param float $value the value to use
+	 */
+	public function setRegexSlop($value)
+	{
+		$this->setParameterValue('hl.regex.slop',$value);
+	}
+	
+	/**
+	 * Get the regex slop value (the percentage with which the regex fragmenter can
+	 * stray in size.
+	 * 
+	 * @return float the slop value for the regex fragementer
+	 */
+	public function getRegexSlop()
+	{
+		return $this->getParameterValue('hl.regex.slop');
+	}
+	
+	/**
+	 * The regular expression for fragmenting. This could be used to extract 
+	 * sentences (see example solrconfig.xml)
+	 *  
+	 * @param string $value the regex to use for fragmenting
+	 */
+	public function setRegexPattern($value)
+	{
+		$this->setParameterValue('hl.regex.pattern',$value);
+	}
+	
+	/**
+	 * Get the regex used for fragmenting.
+	 * 
+	 * @return string the regex used for fragmenting
+	 */
+	public function getRegexPattern()
+	{
+		return $this->getParameterValue('hl.regex.pattern');
+	}
+	
+	/**
+	 * Only analyze this many characters from a field when using the regex 
+	 * fragmenter (after which, the fragmenter produces fixed-sized fragments).
+	 * Applying a complicated regex to a huge field is expensive.
+	 * 
+	 * The default value is "10000".
+	 * 
+	 * @param int $value the max number of characters to analyze with the regex 
+	 */
+	public function setRegexMaxAnalyzedChars($value)
+	{
+		$this->setParameterValue('hl.regex.maxAnalyzedChars',$value);
+	}
+	
+	/**
+	 * Get the max number of characters to analyze with a regex fragmenter.
+	 * 
+	 * @return int the max number of characters to analyze with a regex fragmenter
+	 */
+	public function getRegexMaxAnalyzedChars()
+	{
+		return $this->getParameterValue('hl.regex.maxAnalyzedChars');
+	}
+	
+	/**
+	 * This function should return whether or not the $param fed in accepts field overrides
+	 * or not.
+	 *
+	 * @param string $param this is the parameter you are testing for overrideability
+	 * @return boolean true if it overrideable, false if it isn't
+	 */
+	protected function isOverrideable($param) 
+	{
+		return self::$param_info[$param]['ovr'];
+	}
+	
+	/**
+	 * This function returns the type of parameter that $param is.
+	 *
+	 * @param string $param the parameter whose type you want
+	 * @return string the type the parameter is.
+	 */
+	protected function getParamType($param)
+	{
+		return self::$param_info[$param]['type'];
+	}
+
+	/**
+	 * This function returns the default value of a parameter.
+	 *
+	 * @param string $param the parameter you want the default value for
+	 * @return string the default value of the parameter
+	 */
+	protected function getDefaultValue($param)
+	{
+		return self::$param_info[$param]['default'];
+	}
+}
\ No newline at end of file
Index: Apache/Solr/Document.php
===================================================================
--- Apache/Solr/Document.php	(revision 53)
+++ Apache/Solr/Document.php	(working copy)
@@ -87,6 +87,13 @@
 	 * @var array array of floats
 	 */
 	protected $_fieldBoosts = array();
+	
+	/**
+	 * Document field highlight values, indexed by name.
+	 * 
+	 * @var array array of strings
+	 */
+	protected $_fieldHighlighting = array();
 
 	/**
 	 * Clear all boosts and fields from this document
@@ -97,6 +104,7 @@
 
 		$this->_fields = array();
 		$this->_fieldBoosts = array();
+		$this->_fieldHighlighting = array();
 	}
 
 	/**
@@ -206,7 +214,8 @@
 			return array(
 				'name' => $key,
 				'value' => $this->_fields[$key],
-				'boost' => $this->getFieldBoost($key)
+				'boost' => $this->getFieldBoost($key),
+				'highlighting' => $this->getFieldHighlighting($key)
 			);
 		}
 
@@ -258,6 +267,30 @@
 			$this->_fieldBoosts[$key] = false;
 		}
 	}
+	
+	/**
+	 * This function retrieves the highlighting for a given field 
+	 * 
+	 * @param string $key field name for the highlighting
+	 * @return string the highlighting for the field
+	 */
+	public function getFieldHighlighting($key)
+	{
+		return isset($this->_fieldHighlighting[$key]) ? $this->_fieldHighlighting[$key] : false;
+	}
+	
+	/**
+	 * This function sets the highlighting for a given field.  Highlighting
+	 * cannot and will not be sent back to the Solr server, so don't use this
+	 * function thinking it will be persisted in any manner.
+	 * 
+	 * @param string $key field name for the highlighting
+	 * @param string $value the highlighting for that field
+	 */
+	public function setFieldHighlighting($key, $value)
+	{
+		$this->_fieldHighlighting[$key] = $value;
+	}
 
 	/**
 	 * Return current field boosts, indexed by field name
